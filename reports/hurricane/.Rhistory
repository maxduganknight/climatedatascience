seas5 <- seas5[, c('tp', 'year', 'number', 'step')]
seas5$step <- as.numeric(gsub(" days", "", seas5$step))
################################################################################
## plot
################################################################################
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
View(era5)
era5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_annual_max.csv')
#era5$year <- as.Date(era5$year)
era5 <- era5[order(era5$year), ]
seas5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/SEAS5_annual_max.csv')
seas5 <- seas5[order(seas5$year), ]
seas5 <- seas5[, c('tp', 'year', 'number', 'step')]
seas5$step <- as.numeric(gsub(" days", "", seas5$step))
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
params <- fit_stationary$results$par
se <- sqrt(diag(fit_stationary$results$cov))
location <- params["location"]
scale <- params["scale"]
shape <- params["shape"]
se_location <- se["location"]
se_scale <- se["scale"]
se_shape <- se["shape"]
# Define return periods
return_periods <- c(2, 5, 10, 20, 50, 100)
# Function to calculate return levels
calculate_return_levels <- function(loc, scale, shape, return_periods) {
return_levels <- loc + scale / shape * ((-log(1 - 1 / return_periods))^(-shape) - 1)
return(return_levels)
}
calculate_return_level_ci <- function(loc, scale, shape, se_loc, se_scale, se_shape, return_periods, alpha = 0.05) {
z <- qnorm(1 - alpha / 2)
delta <- scale / shape * ((-log(1 - 1 / return_periods))^(-shape) - 1)
se_delta <- sqrt((se_loc / shape)^2 + (se_scale / shape)^2 + (se_shape * delta)^2)
return_levels <- loc + delta
ci_lower <- return_levels - z * se_delta
ci_upper <- return_levels + z * se_delta
return(data.frame(return_periods, return_levels, ci_lower, ci_upper))
}
# Calculate return levels and confidence intervals
rl_ci <- calculate_return_level_ci(location, scale, shape, se_location, se_scale, se_shape, return_periods)
# Create a data frame for plotting
return_level_df <- data.frame(
ReturnPeriod = return_periods,
ReturnLevel = rl_ci$return_levels,
LowerCI = rl_ci$ci_lower,
UpperCI = rl_ci$ci_upper
)
return_level_df
fit_non_stationary <- fevd(tp, data = seas5,
location.fun = ~ year, scale.fun = ~ year, shape.fun = ~ year)
fit_non_stationary_location <- fevd(tp, data = seas5,
location.fun = ~ year,
type = "GEV")
fit_non_stationary_location
fit_non_stationary_location$missing.values
sum(fit_non_stationary_location$missing.values)
fit_non_stationary_location <- fevd(tp, data = seas5,
location.fun = ~ year,
type = "GEV", use.phi = TRUE)
fit_non_stationary_location
fit_non_stationary_location$par.models
fit_non_stationary_location$results
return.level(fit_non_stationary_location, return.period = return_periods)
fit_non_stationary_location
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
earliest_year <- min(seas5$year)
latest_year <- max(seas5$year)
qcov_earliest <- make.qcov(fit_non_stationary_location, vals = list(mu1 = earliest_year))
qcov_latest <- make.qcov(fit_non_stationary_location, vals = list(mu1 = latest_year))
# Calculate return levels for the earliest year
return_levels_earliest <- return.level(fit_non_stationary_location, return.period = return_periods, qcov = qcov_earliest)
# Calculate return levels for the latest year
return_levels_latest <- return.level(fit_non_stationary_location, return.period = return_periods, qcov = qcov_latest)
return_levels_earliest
return_levels_latest
return_level_df <- data.frame(
ReturnPeriod = return_periods,
EarliestYear = earliest_return_levels,
LatestYear = latest_return_levels
)
return_level_df <- data.frame(
ReturnPeriod = return_periods,
EarliestYear = return_levels_earliest,
LatestYear = return_levels_latest
)
# Plot the return levels
ggplot(return_level_df, aes(x = ReturnPeriod)) +
geom_line(aes(y = EarliestYear, color = "Earliest Year"), size = 1.2) +
geom_line(aes(y = LatestYear, color = "Latest Year"), size = 1.2) +
labs(title = "Return Level Plot for Non-Stationary GEV Model",
x = "Return Period (years)",
y = "Return Level",
color = "Legend") +
theme_minimal()
return_levels_earliest
return_levels_earliest[1,]
return_level_df <- data.frame(
ReturnPeriod = return_periods,
EarliestYear = return_levels_earliest[1,],
LatestYear = return_levels_latest[1,]
)
# Plot the return levels
ggplot(return_level_df, aes(x = ReturnPeriod)) +
geom_line(aes(y = EarliestYear, color = "Earliest Year"), size = 1.2) +
geom_line(aes(y = LatestYear, color = "Latest Year"), size = 1.2) +
labs(title = "Return Level Plot for Non-Stationary GEV Model",
x = "Return Period (years)",
y = "Return Level",
color = "Legend") +
theme_minimal()
timeseries + theme(text = element_text(size = 14))
library(ncdf4)
library(extRemes)
library(ggplot2)
library(dplyr)
library(tidyr)
library(knitr)
library(cowplot)
require(UNSEEN)
require(lubridate)
library(evd)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
source('../../../UNSEEN-open-Deep-Sky/src/evt_plot.r')
era5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_annual_max_v2.csv')
#era5$year <- as.Date(era5$year)
era5 <- era5[order(era5$year), ]
seas5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/SEAS5_annual_max_v2.csv')
seas5 <- seas5[order(seas5$year), ]
seas5$tp_biascor = seas5$tp + (mean(era5$tp) - mean(seas5$tp))
seas5 <- seas5[, c('tp', 'year', 'number', 'step')]
seas5$step <- as.numeric(gsub(" days", "", seas5$step))
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp_biascor",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
seas5$tp_biascor = seas5$tp + (mean(era5$tp) - mean(seas5$tp))
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp_biascor",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
library(ncdf4)
library(extRemes)
library(ggplot2)
library(dplyr)
library(tidyr)
library(knitr)
library(cowplot)
require(UNSEEN)
require(lubridate)
library(evd)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
source('../../../UNSEEN-open-Deep-Sky/src/evt_plot.r')
era5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_annual_max_v2.csv')
#era5$year <- as.Date(era5$year)
era5 <- era5[order(era5$year), ]
seas5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/SEAS5_annual_max_v2.csv')
seas5 <- seas5[order(seas5$year), ]
seas5$tp_biascor = seas5$tp + (mean(era5$tp) - mean(seas5$tp))
seas5 <- seas5[, c('tp', 'year', 'number', 'step')]
seas5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/SEAS5_annual_max_v2.csv')
seas5 <- seas5[order(seas5$year), ]
seas5$tp_biascor = seas5$tp + (mean(era5$tp) - mean(seas5$tp))
seas5 <- seas5[, c('year', 'number', 'tp', 'tp_biascor')]
# seas5$step <- as.numeric(gsub(" days", "", seas5$step))
################################################################################
## plot
################################################################################
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp_biascor",
ensemble_xname = "year",
obs_yname = "tp",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
fit_stationary <- fevd(tp, data = seas5, type = "GEV")
fit_non_stationary <- fevd(tp_biascor, data = seas5,
location.fun = ~ year, scale.fun = ~ year, shape.fun = ~ year)
era5$tp_biascor = era5$tp + (mean(seas5$tp) - mean(era5$tp))
era5$tp_biascor = era5$tp + (mean(seas5$tp) - mean(era5$tp))
seas5 <- seas5[, c('year', 'number', 'tp')]
# seas5$step <- as.numeric(gsub(" days", "", seas5$step))
################################################################################
## plot
################################################################################
timeseries = unseen_timeseries(
ensemble = seas5,
obs = era5,
ensemble_yname = "tp",
ensemble_xname = "year",
obs_yname = "tp_biascor",
obs_xname = "year",
ylab = "Precipitation")
timeseries + theme(text = element_text(size = 14))
fit_non_stationary <- fevd(tp, data = seas5,
location.fun = ~ year, scale.fun = ~ year, shape.fun = ~ year)
fit_non_stationary_location <- fevd(tp, data = seas5,
location.fun = ~ year,
type = "GEV", use.phi = TRUE)
era5_top3 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_top_5_annual_events.csv')
era5_top3 <- era5_top3[order(era5_top3$year), ]
era5_top3 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_top_5_annual_events.csv')
era5_top3 <- era5_top3[order(era5_top3$year), ]
# Fit the non-stationary GEV model using the year as a covariate
fit_stationary <- fevd(era5_top3$tp, type = "GEV")
fit_non_stationary_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year,
#scale.fun = ~ era5_top3$year,
type = "GEV")
fit_non_stationary_scale <- fevd(x = era5_top3$tp,
#location.fun = ~ era5_top3$year,
scale.fun = ~ era5_top3$year,
type = "GEV")
fit_non_stationary_both <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year,
scale.fun = ~ era5_top3$year,
type = "GEV")
fit_non_linear_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year + I(era5_top3$year^2),
#scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
fit_non_linear_scale <- fevd(x = era5_top3$tp,
scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
fit_non_linear_both <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year + I(era5_top3$year^2),
scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
fit_non_stationary_shape <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year,
# scale.fun = ~ era5_top3$year,
shape.fun = ~ era5_top3$year,
type = "GEV")
fit_combined <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year,
scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
fit_interaction_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year * era5_top3$tp,
#scale.fun = ~ era5_top3$year * era5_top3$tp,
type = "GEV")
fit_interaction_both <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year * era5_top3$tp,
scale.fun = ~ era5_top3$year * era5_top3$tp,
type = "GEV")
models <- list(fit_stationary,
fit_non_stationary_location,
fit_non_stationary_scale,
fit_non_stationary_both,
fit_non_linear_location,
fit_non_linear_scale,
fit_non_linear_both,
fit_non_stationary_shape,
fit_combined,
fit_interaction)
models <- list(fit_stationary,
fit_non_stationary_location,
fit_non_stationary_scale,
fit_non_stationary_both,
fit_non_linear_location,
fit_non_linear_scale,
fit_non_linear_both,
fit_non_stationary_shape,
fit_combined,
fit_interaction_location,
fit_interaction_both)
extract_aic_bic <- function(model) {
summary_model <- summary(model)
c(AIC = summary_model$AIC, BIC = summary_model$BIC)
}
model_criteria <- sapply(models, extract_aic_bic)
model_criteria
lr.test(fit_stationary, fit_non_stationary_location)
# Define a function to calculate return values and confidence intervals
RV_ci <- function(fit, qcov_start, qcov_end, return_periods) {
ci_start <- ci(fit, alpha = 0.05, type = 'return.level', return.period = return_periods, qcov = qcov_start)
ci_end <- ci(fit, alpha = 0.05, type = 'return.level', return.period = return_periods, qcov = qcov_end)
results <- data.frame(
Return_Period = return_periods,
Start_Central = ci_start[, 2],
Start_Lower = ci_start[, 1],
Start_Upper = ci_start[, 3],
End_Central = ci_end[,2],
End_Lower = ci_end[, 1],
End_Upper = ci_end[, 3]
)
return(results)
}
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
earliest_year <- min(era5_top3$year)
latest_year <- max(era5_top3$year)
qcov_earliest <- make.qcov(fit_non_stationary_both, vals = list(mu1 = earliest_year, sigma1 = earliest_year))
qcov_latest <- make.qcov(fit_non_stationary_both, vals = list(mu1 = latest_year, sigma1 = latest_year))
results <- RV_ci(fit_non_stationary_location, qcov_earliest, qcov_latest, return_periods)
results <- results %>%
mutate(Start_Year = "1981", End_Year = "2023")
results
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
earliest_year <- min(era5_top3$year)
latest_year <- max(era5_top3$year)
qcov_earliest <- make.qcov(fit_non_stationary_location, vals = list(mu1 = earliest_year, sigma1 = earliest_year))
era5_top3 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_619.csv')
era5_top3 <- era5_top3[order(era5_top3$year), ]
era5_top3 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_619.csv')
era5_top3 <- era5_top3[order(era5_top3$time), ]
# Fit the non-stationary GEV model using the year as a covariate
fit_stationary <- fevd(era5_top3$tp, type = "GEV")
summary(fit_stationary)
fit_non_stationary_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$time,
#scale.fun = ~ era5_top3$year,
type = "GEV")
era5_severity <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/yearly_95th_percentile_severity.csv')
View(era5_severity)
era5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_annual_max.csv')
View(era5)
era5 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_annual_max_620.csv')
era5 <- era5[order(era5$time), ]
fit_stationary <- fevd(era5$tp, type = "GEV")
fit_non_stationary_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$time,
#scale.fun = ~ era5_top3$year,
type = "GEV")
fit_stationary <- fevd(era5$tp, type = "GEV")
fit_non_stationary_location <- fevd(x = era5$tp,
location.fun = ~ era5$time,
#scale.fun = ~ era5_top3$year,
type = "GEV")
fit_non_stationary_scale <- fevd(x = era5$tp,
#location.fun = ~ era5_top3$year,
scale.fun = ~ era5$time,
type = "GEV")
era5$year <- format(era5$time, "%Y")
era5$time <- as.Date(era5$time)
era5$year <- format(era5$time, "%Y")
era5$year <- as.factor(era5$year)
fit_stationary <- fevd(era5$tp, type = "GEV")
fit_non_stationary_location <- fevd(x = era5$tp,
location.fun = ~ era5$year,
#scale.fun = ~ era5_top3$year,
type = "GEV")
summary(fit_non_stationary_location)
lr.test(fit_stationary, fit_non_stationary_location)
plot(fit_non_stationary_location)
fit_non_stationary_scale <- fevd(x = era5$tp,
#location.fun = ~ era5_top3$year,
scale.fun = ~ era5$year,
type = "GEV")
summary(fit_non_stationary_scale)
fit_non_stationary_both <- fevd(x = era5$tp,
location.fun = ~ era5$year,
scale.fun = ~ era5$year,
type = "GEV")
summary(fit_non_stationary_both)
fit_non_linear_location <- fevd(x = era5$tp,
location.fun = ~ era5_top3$year + I(era5$year^2),
#scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
fit_non_linear_location <- fevd(x = era5$tp,
location.fun = ~ era5$year + I(era5$year^2),
#scale.fun = ~ era5_top3$year + I(era5_top3$year^2),
type = "GEV")
summary(fit_non_stationary_location)
return_periods <- c(10, 20, 50, 100)  # Example return periods
return_levels <- return.level(fit_non_stationary_location, return.period = return_periods)
return_levels
# Calculate return levels for specific return periods
return_periods <- c(10, 20, 50, 100)  # Example return periods (in years)
# Retrieve the location parameter for the first and last years
location_first_year <- predict(fit_non_stationary_location, newdata = data.frame(year = first_year))$location
location_coefficients <- fit_non_stationary_location$results$par[grep("^mu", names(fit_non_stationary_location$results$par))]
calculate_location <- function(year, coefficients) {
# Assuming the model is of the form mu = mu0 + mu1*year + mu2*year^2 + ...
location <- coefficients[1]  # Intercept
for (i in 2:length(coefficients)) {
location <- location + coefficients[i] * year^(i-1)
}
return(location)
}
# Calculate location parameter for the first and last years
location_first_year <- calculate_location(first_year, location_coefficients)
location_coefficients <- fit_non_stationary_location$results$par[grep("^mu", names(fit_non_stationary_location$results$par))]
first_year <- min(era5$year)
era5$year <- as.numeric(as.character(era5$year))
# Extract the first and last years from the era5 dataset
first_year <- min(era5$year, na.rm = TRUE)
last_year <- max(era5$year, na.rm = TRUE)
location_coefficients <- fit_non_stationary_location$results$par[grep("^mu", names(fit_non_stationary_location$results$par))]
calculate_location <- function(year, coefficients) {
# Assuming the model is of the form mu = mu0 + mu1*year + mu2*year^2 + ...
location <- coefficients[1]  # Intercept
for (i in 2:length(coefficients)) {
location <- location + coefficients[i] * year^(i-1)
}
return(location)
}
# Calculate location parameter for the first and last years
location_first_year <- calculate_location(first_year, location_coefficients)
location_last_year <- calculate_location(last_year, location_coefficients)
calculate_return_levels <- function(location, scale, shape, return_periods) {
q <- 1 - 1/return_periods
return_levels <- location + scale / shape * ((-log(q))^(-shape) - 1)
return(data.frame(return_period = return_periods, return_level = return_levels))
}
# Extract scale and shape parameters from the fitted model
scale <- fit_non_stationary_location$results$par["scale"]
shape <- fit_non_stationary_location$results$par["shape"]
# Define return periods
return_periods <- c(10, 20, 50, 100)  # Example return periods (in years)
# Calculate return levels for the first and last years
return_levels_first_year <- calculate_return_levels(location_first_year, scale, shape, return_periods)
return_levels_last_year <- calculate_return_levels(location_last_year, scale, shape, return_periods)
# Add a column to indicate the year
return_levels_first_year$year <- first_year
return_levels_last_year$year <- last_year
# Combine the return levels for the first and last years into one dataframe
comparison_df <- rbind(return_levels_first_year, return_levels_last_year)
# Print the comparison dataframe
print(comparison_df)
era5_top3 <- read.csv('../../data/UNSEEN/hurricane/rainfall_preprocessed/ERA5_top_3_annual_events.csv')
era5_top3 <- era5_top3[order(era5_top3$time), ]
# Fit the non-stationary GEV model using the year as a covariate
fit_stationary <- fevd(era5_top3$tp, type = "GEV")
fit_non_stationary_location <- fevd(x = era5_top3$tp,
location.fun = ~ era5_top3$year,
#scale.fun = ~ era5_top3$year,
type = "GEV")
plot(fit_non_stationary_location)
summary(fit_non_stationary_location)
RV_ci <- function(fit, qcov_start, qcov_end, return_periods) {
ci_start <- ci(fit, alpha = 0.05, type = 'return.level', return.period = return_periods, qcov = qcov_start)
ci_end <- ci(fit, alpha = 0.05, type = 'return.level', return.period = return_periods, qcov = qcov_end)
results <- data.frame(
Return_Period = return_periods,
Start_Central = ci_start[, 2],
Start_Lower = ci_start[, 1],
Start_Upper = ci_start[, 3],
End_Central = ci_end[,2],
End_Lower = ci_end[, 1],
End_Upper = ci_end[, 3]
)
return(results)
}
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
earliest_year <- min(era5_top3$year)
latest_year <- max(era5_top3$year)
qcov_earliest <- make.qcov(fit_non_stationary_location, vals = list(mu1 = earliest_year, sigma1 = earliest_year))
summary(fit_non_stationary_location)
return_periods <- c(2, 3, 4, 5, 7, 10, 20, 50, 75, 100)
earliest_year <- min(era5_top3$year)
latest_year <- max(era5_top3$year)
qcov_earliest <- make.qcov(fit_non_stationary_location, vals = list(mu = c(1, earliest_year)))
earliest_year <- min(era5_top3$year)
latest_year <- max(era5_top3$year)
qcov_earliest <- make.qcov(fit_non_stationary_location, vals = list(mu0 = 1, mu1 = earliest_year))
qcov_latest <- make.qcov(fit_non_stationary_location, vals = list(mu0 = 1, mu1 = latest_year))
results <- RV_ci(fit_non_stationary_location, qcov_earliest, qcov_latest, return_periods)
results <- results %>%
mutate(Start_Year = "1981", End_Year = "2023")
results
era5_top3
ggplot(results, aes(x = Return_Period)) +
geom_line(aes(y = Start_Central, color = Start_Year), linewidth = 1) + # Use `linewidth` instead of `size`
geom_ribbon(aes(ymin = Start_Lower, ymax = Start_Upper, fill = Start_Year), alpha = 0.5) +
geom_line(aes(y = End_Central, color = End_Year), linewidth = 1) + # Use `linewidth` instead of `size`
geom_ribbon(aes(ymin = End_Lower, ymax = End_Upper, fill = End_Year), alpha = 0.5) +
scale_x_continuous(trans = 'log10') +
theme_classic() +
xlab('Return period (years)') +
ylab('5-Day Rainfall Return Level') +
scale_color_manual(name = "Year", values = c("1981" = "black", "2023" = "red")) +
scale_fill_manual(name = "Year", values = c("1981" = "black", "2023" = "red"))
